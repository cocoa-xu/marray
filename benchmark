#!/usr/bin/env escript
%% -*- erlang -*-
%%! -pa ./_build/default/lib/marray/ebin -Wall
main([REPEAT_TIMES | ARRAY_LENGTH]) ->
    try
        R = list_to_integer(REPEAT_TIMES),
        lists:foreach(
            fun(X) ->
                N = list_to_integer(X),
                benchmark(N, R),
                io:format("~n")
            end,
            ARRAY_LENGTH
        )
    catch
        A:B:C ->
            io:format("Error: ~p: ~p~n~p~n", [A, B, C]),
            usage()
    end;
main(_) ->
    usage().

usage() ->
    io:format("usage: benchmark REPEAT_TIMES [[ARRAY_LENGTH...]]~n"),
    halt(1).

generate_list(N) when N > 0 ->
    generate_list(N, []).
generate_list(0, Acc) ->
    Acc;
generate_list(N, Acc) ->
    RandomInt = rand:uniform(100 * N),
    generate_list(N - 1, [RandomInt | Acc]).

benchmark(N, R) when N > 0 ->
    io:format("Benchmarking with array length ~p~n", [N]),
    Benchmark = fun(Fun) ->
        {_Pid, Ref} = spawn_monitor(fun() ->
            {Time, _} = timer:tc(Fun, []),
            exit(Time)
        end),
        receive
          {'DOWN', Ref, _, _, Time} -> Time
        end
    end,
    ElapsedTimes = lists:map(
        fun(_I) ->
            List = generate_list(N),
            Marray = marray:from_list(List),
            %% Assert the results match
            true = (marray:to_list(benchmark_marray(Marray)) =:= benchmark_list(List)),
            [
              Benchmark(fun() -> benchmark_marray(Marray) end),
              Benchmark(fun() -> benchmark_list(List) end)
            ]
        end,
        lists:seq(1, R)
    ),
    [MarrayTimes, ListTimes] = lists:foldr(
        fun([MarrayTime, ListTime], [MarrayTimes, ListTimes]) ->
            [[MarrayTime| MarrayTimes],[ListTime | ListTimes]]
        end,
        [[], []],
        ElapsedTimes
    ),
    MarrayAvg = lists:sum(MarrayTimes) / length(MarrayTimes),
    ListAvg = lists:sum(ListTimes) / length(ListTimes),
    MarrayMax = lists:max(MarrayTimes),
    ListMax = lists:max(ListTimes),
    MarrayMin = lists:min(MarrayTimes),
    ListMin = lists:min(ListTimes),
    MarrayStdDev = math:sqrt(lists:sum(lists:map(fun(X) -> math:pow(X - MarrayAvg, 2) end, MarrayTimes)) / length(MarrayTimes)),
    ListStdDev = math:sqrt(lists:sum(lists:map(fun(X) -> math:pow(X - ListAvg, 2) end, ListTimes)) / length(ListTimes)),
    MarrayStdDev1 = round(MarrayStdDev * 100) / 100,
    ListStdDev1 = round(ListStdDev * 100) / 100,
    io:format("Marray: avg=~p, max=~p, min=~p, stddev=~p~n", [MarrayAvg, MarrayMax, MarrayMin, MarrayStdDev1]),
    io:format("List:   avg=~p, max=~p, min=~p, stddev=~p~n", [ListAvg, ListMax, ListMin, ListStdDev1]),
    ok;
benchmark(_, _) ->
    usage().

benchmark_marray(Marray) ->
    quicksort(Marray).

quicksort(Marray) ->
    R = marray:size(Marray) - 1,
    quicksort(Marray, 0, R).

quicksort(Marray, L, R) when L < R ->
    PivotIndex = partition(Marray, L, R),
    quicksort(Marray, L, PivotIndex - 1),
    quicksort(Marray, PivotIndex + 1, R);
quicksort(Marray, _L, _R) ->
    Marray.

partition(Marray, L, R) ->
    Pivot = marray:get(Marray, R),
    I = partition(R - 1, L, L - 1, Pivot, Marray),
    marray:swap(Marray, I + 1, R),
    I + 1.

partition(R, L, I, Pivot, Marray) when R >= L ->
    Val = marray:get(Marray, R),
    case Val < Pivot of
        true ->
            marray:swap(Marray, I + 1, R),
            partition(R - 1, L, I + 1, Pivot, Marray);
        false ->
            partition(R - 1, L, I, Pivot, Marray)
    end;
partition(_R, _L, I, _Pivot, _Marray) ->
    I.

benchmark_list(List) ->
    qsort(List).

qsort([]) ->
    [];
qsort([Pivot | T]) ->
    qsort([X || X <- T, X < Pivot]) ++ [Pivot] ++ qsort([X || X <- T, X >= Pivot]).
